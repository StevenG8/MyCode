/*如果要写递归的函数，确定要输入的参数是关键，这个输入的参数要做到切分问题的作用*/
/*想清楚你这个递归函数是适用于什么情形下，如果递归执行到了不符合的情况该怎么做（其实也就是基准）*/
/*把所有可能的不符合的情况全部另外处理，完成基准任务，这个递归函数就完成了*/

//在任何一个数组的递归函数中，既然都叫递归了，那肯定是把数组不断的切分处理
//既然传入参数是一样，那么输入数组的两头的下标是一个非常好的想法，等同将数组不断划分
//最后确定一下当切分到足够小的时候该如何处理即可


/*
指针是存放地址的变量，而且它是有自己的地址的
也就是说，指针里面赋值的是一个地址A，而指针自己本身是地址B
指针与指针的赋值其实跟普通变量的赋值没有很大的区别，区别只在于指针的赋值是地址
任何一个申请的变量的地址我们是无法去改变的，只能改变这个地址上存放的数据

free()释放的是指针指向的内存！注意！释放的是内存，不是指针！
指针并没有被释放，指针仍然指向原来的存储空间。
指针是一个变量，只有程序结束时才被销毁。
释放了内存空间后，原来指向这块空间的指针还是存在！
只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。
因此，释放内存后把指针指向NULL，防止指针在后面不小心又被解引用了。
*/


/*
  int i=1;
  int a=i++;
  int b=++i;
  第二行中，a=1，i=i+1=2；
  第三行中，b=i+1=2+1=3；
*/


/*
  头拿出来，中间顶上去，头插到尾巴去
*/


//------优秀的代码有普适性,推广性
//就像数学里的自变量x,f(x)==(x=sint)==f(sint),f(x)==(x=cosu)==f(cosu).
//函数的输入参数可以是简单的单个数据,也可以是树,也可以是结构
//你在构建这个函数的时候只需要将它抽象为简单的单个数据即可
//输入参数类型的变化导致的变动普遍不会很大,修修补补即可
//但需注意:
//若是在树这样的数据结构中,输入参数从简单的单个数据改成了树,就基本不能用.
//除非是能保证不会树中插树(最小堆(完全二叉树)的哈夫曼应用,!!把树插到数组对应位置而不是插到树的子树上,是链式结构和顺序结构的混用!!)



/*这里可以借鉴其思想,就只是想要递归的最终结果来搞事情*/
/*----------------集合的压缩最短路径----------------*/
//最终结果使得这个集合上的结点直接连到了集合头上,把路径缩短
SetName DiminishFindRoot(Settype A[],ElementType X)
{
  if(A[X]<0)  return X;
  else
    return A[X]=Find(A,A[X]);//尾递归!

  //这里返回的是A[X],只是在返回前要先对其赋值
  //可以反过来理解,Find函数一直在调用自己,直到找到根节点
  //找到根节点后其下的第一个结点就对其父节点赋值为根节点,然后返回其父节点(也就是根节点)
  //而后根节点下的第二个节点通过Find函数得到的是根节点,他也将其赋值为其父节点
  //以此类推,最后原本根节点下的结点直接以最短路径挂在根节点下

  //不纠结于细节的简单理解是这样的:
  //return A[X]=Find(A,A[X]);
  //其实说白了就是把递归最终得到的结果同样的返回到了每一个中间递归
  //只是多做了一个赋值,而这里的赋值的意义仅仅是将其最终结果作为其父节点

}
